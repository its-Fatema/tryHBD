<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Birthday Wish (Light Theme)</title>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            /* CHANGE 1: WHITE BG */
            background-color: #f8f9fa; 
            font-family: 'Poppins', sans-serif; 
            color: #333;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- LIGHT THEME UI --- */
        #ui-container {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            z-index: 100;
            display: flex; flex-direction: column; align-items: center; gap: 15px;
            width: 90%; max-width: 500px;
        }

        .glass-box {
            /* Darker tint for light bg */
            background: rgba(0, 0, 0, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            padding: 20px; border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            display: flex; gap: 10px; width: 100%;
        }

        input {
            flex: 1; background: transparent; border: none; outline: none;
            color: #333; /* Dark text */
            font-size: 1.1rem; text-align: center;
            border-bottom: 2px solid rgba(0,0,0,0.2);
            padding-bottom: 5px; font-family: 'Poppins', sans-serif;
        }
        input::placeholder { color: rgba(0,0,0,0.4); }
        input:focus { border-bottom-color: #ff00de; }

        button {
            background: linear-gradient(135deg, #ff00de, #00eaff);
            border: none; padding: 12px 25px; color: white;
            font-weight: 700; border-radius: 50px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 0, 222, 0.3);
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }

        /* STATUS MESSAGES */
        #overlay-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #333; pointer-events: none;
            z-index: 50; 
        }
        .big-text { font-size: 2rem; font-weight: 700; margin-bottom: 10px; color: #d600ff; }
        .sub-text { font-size: 1.1rem; opacity: 0.8; font-weight: 600; color: #555; }
        
        #camera-hint {
            position: absolute; top: 10px; width: 100%; text-align: center;
            font-size: 0.9rem; color: #ff0055; font-weight: bold;
            z-index: 200; display: none;
        }

        .input_video { display: none; }
    </style>
</head>
<body>

    <div id="camera-hint">‚ö†Ô∏è Camera requires Localhost or HTTPS to work!</div>

    <div id="ui-container">
        <div class="glass-box" id="input-area">
            <input type="text" id="nameInput" placeholder="Enter Name (e.g. Priya)" maxlength="12">
            <button onclick="generateLink()">Create Magic</button>
        </div>
        <div style="color: rgba(0,0,0,0.5); font-size: 0.8rem; text-align: center;">
            Enter a name to create a shareable link.
        </div>
    </div>

    <div id="overlay-msg">
        <div class="big-text" id="msg-title">Initializing...</div>
        <div class="sub-text" id="msg-sub">üëã Please allow camera access to control the magic!</div>
    </div>

    <video class="input_video"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
    // --- STATE MANAGEMENT ---
    const params = new URLSearchParams(window.location.search);
    const encodedName = params.get('n');
    let targetName = "";

    if(window.location.protocol === 'file:') {
        document.getElementById('camera-hint').style.display = 'block';
    }

    function initApp() {
        if (encodedName) {
            try {
                targetName = atob(encodedName);
                document.getElementById('ui-container').style.display = 'none'; // Hide input for receiver
            } catch (e) { console.error("Invalid Name"); }
        } else {
             // If creator mode, hide the "allow camera" message initially
             document.getElementById('overlay-msg').style.display = 'none';
        }
        
        initThree();
        // CHANGE 2: START CAMERA IMMEDIATELY FOR TESTING
        startCamera(); 
    }

    function generateLink() {
        const name = document.getElementById('nameInput').value.trim();
        if(!name) return;
        const link = `${window.location.origin}${window.location.pathname}?n=${btoa(name)}`;
        navigator.clipboard.writeText(link).then(() => { alert("Link copied! Send it to " + name); });
    }

    // --- 3D ENGINE ---
    let scene, camera, renderer, particles, textMesh;
    let handPos = { x: 0, y: 0, active: false };
    let clock = new THREE.Clock();

    function initThree() {
        scene = new THREE.Scene();
        // CHANGE 3: WHITE FOG
        scene.fog = new THREE.FogExp2(0xf8f9fa, 0.002);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0xf8f9fa); // Explicit white clear color
        document.body.appendChild(renderer.domElement);

        createConfettiParticles(); // Renamed function
        createFancyText();
        animate();
    }

    // CHANGE 4: NEW PARTICLE SYSTEM (CONFETTI) FOR LIGHT BG
    function createConfettiParticles() {
        const count = 15000;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];

        // CHANGE 5: DARKER, VIBRANT PALETTE
        const palette = [
            new THREE.Color('#d600ff'), // Deep Magenta
            new THREE.Color('#0051ff'), // Deep Blue
            new THREE.Color('#ff5e00'), // Deep Orange
            new THREE.Color('#00bfa5')  // Teal
        ];

        for(let i=0; i<count; i++) {
            positions.push((Math.random()-0.5)*150, (Math.random()-0.5)*150, (Math.random()-0.5)*100);
            const c = palette[Math.floor(Math.random()*palette.length)];
            colors.push(c.r, c.g, c.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        // CHANGE 6: SOLID MATERIAL (No glowing additive blending)
        const material = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            // blending: THREE.AdditiveBlending // DISABLED for light mode
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    // CHANGE 7: DARK TEXT FOR LIGHT BG
    function createFancyText() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024; canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        const centerX = 512;
        
        ctx.textAlign = "center";

        // 1. HAPPY
        ctx.font = "800 80px 'Poppins'";
        ctx.fillStyle = "#555"; // Dark Gray
        ctx.fillText("HAPPY", centerX, 300);

        // 2. BIRTHDAY
        ctx.font = "800 100px 'Poppins'";
        ctx.fillStyle = "#d600ff"; // Magenta
        ctx.fillText("BIRTHDAY", centerX, 400);

        // 3. NAME
        if(targetName) {
            ctx.font = "160px 'Pacifico'";
            ctx.fillStyle = "#ff5e00"; // Orange
            ctx.shadowColor = "rgba(0,0,0,0.2)"; ctx.shadowBlur = 20;
            ctx.fillText(targetName, centerX, 600);
        }

        const tex = new THREE.CanvasTexture(canvas);
        // CHANGE 8: NO ADDITIVE BLENDING ON TEXT
        const mat = new THREE.MeshBasicMaterial({ 
            map: tex, transparent: true, side: THREE.DoubleSide
        });
        
        textMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 70), mat);
        textMesh.position.z = -5;
        scene.add(textMesh);
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!particles) return;

        const time = clock.getElapsedTime();
        const positions = particles.geometry.attributes.position.array;
        const count = 15000;

        if(textMesh) {
            textMesh.position.y = Math.sin(time * 0.5) * 2;
        }

        for(let i=0; i<count; i++) {
            let ix = i*3, iy = i*3+1, iz = i*3+2;
            let px = positions[ix];
            let py = positions[iy];
            let pz = positions[iz];

            // CHANGE 9: GESTURE ALWAYS ACTIVE (Removed "&& isReceiver")
            if (handPos.active) {
                // ATTRACTION MODE
                const dx = handPos.x - px;
                const dy = handPos.y - py;
                const dz = 10 - pz;
                
                positions[ix] += dx * 0.08 + (Math.random()-0.5)*1.5; 
                positions[iy] += dy * 0.08 + (Math.random()-0.5)*1.5;
                positions[iz] += dz * 0.08 + (Math.random()-0.5)*1.5; 

            } else {
                // IDLE MODE
                positions[ix] += Math.sin(time * 0.5 + py * 0.05) * 0.1;
                positions[iy] += Math.cos(time * 0.3 + px * 0.05) * 0.1;
                
                // Keep them contained
                if(px > 100 || px < -100) positions[ix] *= 0.9;
                if(py > 80 || py < -80) positions[iy] *= 0.9;
            }
        }
        
        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    function startCamera() {
        const video = document.getElementsByClassName('input_video')[0];
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        
        hands.onResults((results) => {
            // Hide loading message when hand detection is running
            document.getElementById('overlay-msg').style.display = 'none';

            if (results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0][8];
                handPos.x = (0.5 - lm.x) * 100;
                handPos.y = (0.5 - lm.y) * 80;
                handPos.active = true;
            } else {
                handPos.active = false;
            }
        });

        const cam = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });
        cam.start().catch(e => {
            console.error(e);
            alert("Camera failed to start. Ensure you are using a server (localhost or HTTPS).");
        });
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    initApp();

</script>
</body>
</html>
