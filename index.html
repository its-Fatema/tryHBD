<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Birthday Sparkler</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* CONTROLS (Only visible to Creator) */
        #creator-controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; width: 90%; max-width: 600px;
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 20px; border-radius: 20px;
            display: flex; gap: 10px; align-items: center;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            transition: opacity 0.5s;
        }

        input {
            flex: 1; padding: 12px;
            background: rgba(0,0,0,0.5); border: 1px solid #555; color: white;
            border-radius: 10px; text-align: center; font-size: 1rem;
        }
        input:focus { outline: none; border-color: cyan; }

        button {
            background: linear-gradient(45deg, #ff0055, #ff00ff);
            border: none; padding: 12px 25px; color: white;
            font-size: 1rem; border-radius: 25px; cursor: pointer;
            font-weight: bold; white-space: nowrap;
        }
        button:hover { transform: scale(1.05); box-shadow: 0 0 15px #ff00ff; }

        /* MESSAGES */
        #status-msg {
            position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%);
            color: cyan; font-size: 1.2rem; text-shadow: 0 0 10px cyan;
            z-index: 10; pointer-events: none; text-align: center;
            display: none;
            width: 80%;
        }
        
        #hand-instruction {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 0.9rem;
            z-index: 5; pointer-events: none; display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }

        .input_video { display: none; }
    </style>
</head>
<body>

    <div id="creator-controls">
        <input type="text" id="nameInput" placeholder="Enter Name (e.g. Sarah)" maxlength="12">
        <button onclick="generateLink()">Copy Link</button>
    </div>

    <div id="status-msg"></div>
    <div id="hand-instruction">ðŸ‘‹ Show your hand to control the magic!</div>
    <video class="input_video"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    // --- CONFIG ---
    const urlParams = new URLSearchParams(window.location.search);
    const wishName = urlParams.get('n'); 
    const wishTime = urlParams.get('t');
    const EXPIRATION_MINUTES = 20; // Increased to 20 mins for safety

    let finalName = ""; 
    let isReceiverMode = false;

    // --- INITIALIZATION ---
    function init() {
        const creatorControls = document.getElementById('creator-controls');
        const statusMsg = document.getElementById('status-msg');
        const handInstr = document.getElementById('hand-instruction');

        // SAFETY CHECK: Ensure elements exist
        if (!creatorControls || !statusMsg) {
            console.error("HTML Elements missing! Check your ID names.");
            return;
        }

        if (wishName && wishTime) {
            // --- RECEIVER VIEW ---
            const now = Date.now();
            const createdTime = parseInt(wishTime);
            const diffMinutes = (now - createdTime) / 1000 / 60;

            if (diffMinutes > EXPIRATION_MINUTES) {
                statusMsg.style.display = 'block';
                statusMsg.innerText = "âœ¨ The magic has faded... (Link Expired)";
                creatorControls.style.display = 'flex'; 
            } else {
                // VALID LINK
                try {
                    finalName = atob(wishName); 
                } catch(e) {
                    finalName = "Friend";
                }
                
                isReceiverMode = true;
                
                creatorControls.style.display = 'none';
                statusMsg.style.display = 'block';
                statusMsg.innerText = "Igniting Magic Engine...";
                handInstr.style.display = 'block';

                // CHECK FOR CAMERA SUPPORT
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert("âš ï¸ CAMERA BLOCKED: Ensure you are using HTTPS (GitHub Pages) or Localhost.");
                    statusMsg.innerText = "Error: Camera requires HTTPS.";
                    statusMsg.style.color = "red";
                } else {
                    startCamera();
                }
            }
        } 
        
        initThreeJS();
    }

    function generateLink() {
        const input = document.getElementById('nameInput').value.trim();
        if(!input) return alert("Enter a name first!");
        
        const encodedName = btoa(input); 
        const now = Date.now();
        const link = `${window.location.origin}${window.location.pathname}?n=${encodedName}&t=${now}`;
        
        navigator.clipboard.writeText(link).then(() => {
            alert("Link copied! Send it to " + input);
        });
    }

    // --- THREE.JS VISUALS ---
    let scene, camera, renderer, particles, textMesh;
    let isHandDetected = false;
    let targetX = 0, targetY = 0;

    function initThreeJS() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.003);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        createText();
        createParticles();
        animate();
    }

    function createText() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024; 
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = 'rgba(0,0,0,0)'; 
        ctx.fillRect(0, 0, 1024, 1024);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.shadowColor = "#FF00FF";
        ctx.shadowBlur = 30;
        ctx.fillStyle = "white";
        ctx.font = "bold 90px Arial";
        ctx.fillText("HAPPY", 512, 350);

        ctx.shadowColor = "#00FFFF";
        ctx.fillText("BIRTHDAY", 512, 480);

        if(finalName) {
            ctx.shadowColor = "#FFD700"; 
            ctx.fillStyle = "#FFFACD"; 
            ctx.font = "bold 140px sans-serif"; 
            ctx.fillText(finalName.toUpperCase(), 512, 650);
        }

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ 
            map: texture, transparent: true, opacity: 0.95, 
            side: THREE.DoubleSide, blending: THREE.AdditiveBlending 
        });
        textMesh = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), material);
        textMesh.position.z = -10;
        scene.add(textMesh);
    }

    function createParticles() {
        const count = 12000;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const velocities = []; 
        const colors = [];
        const palette = [0xFF0055, 0xFFD700, 0x00FFFF, 0xFFFFFF]; 

        for (let i = 0; i < count; i++) {
            positions.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*100);
            velocities.push(0,0,0);
            const color = new THREE.Color(palette[Math.floor(Math.random()*palette.length)]);
            colors.push(color.r, color.g, color.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

        particles = new THREE.Points(geometry, new THREE.PointsMaterial({
            size: 0.8, vertexColors: true, blending: THREE.AdditiveBlending, 
            transparent: true, opacity: 0.8, depthWrite: false
        }));
        scene.add(particles);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // Safety check to prevent crashing if initialized improperly
        if (!particles) return;

        const posAttr = particles.geometry.attributes.position;
        const velAttr = particles.geometry.attributes.velocity;
        
        const pos = posAttr.array;
        const vel = velAttr.array; 
        
        const speed = isReceiverMode ? 0.1 : 0.05; 
        const returnStrength = 0.008;

        for (let i = 0; i < 12000; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            let px = pos[ix];
            let py = pos[iy];
            let pz = pos[iz];

            let vx = vel[ix]; 
            let vy = vel[iy];
            let vz = vel[iz];

            if (isHandDetected && isReceiverMode) {
                const dx = targetX - px;
                const dy = targetY - py;
                const dz = 20 - pz;
                const distSq = dx*dx + dy*dy + dz*dz;
                const force = Math.min(200/(distSq+1), 2) * speed;
                
                vx += dx * force * 0.1; 
                vy += dy * force * 0.1;
                vz += dz * force * 0.1;
            } else {
                const angle = Date.now() * 0.0001 + (i * 0.0005);
                const radius = 35 + Math.sin(Date.now()*0.0005 + i)*10;
                
                const tx = Math.cos(angle) * radius;
                const ty = Math.sin(angle) * (radius * 0.6);
                
                vx += (tx - px) * returnStrength;
                vy += (ty - py) * returnStrength;
                vz += (-10 - pz) * returnStrength;
            }

            vx *= 0.9; 
            vy *= 0.9;
            vz *= 0.9;

            pos[ix] += vx;
            pos[iy] += vy;
            pos[iz] += vz;
            
            vel[ix] = vx;
            vel[iy] = vy;
            vel[iz] = vz;
        }
        
        posAttr.needsUpdate = true;
        velAttr.needsUpdate = true; 
        
        if(textMesh) {
            textMesh.position.y = Math.sin(Date.now()*0.001)*2;
            textMesh.rotation.z = Math.sin(Date.now()*0.0005)*0.05;
        }

        renderer.render(scene, camera);
    }

    // --- HAND TRACKING ---
    function startCamera() {
        const videoElement = document.getElementsByClassName('input_video')[0];
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults((results) => {
            const statusMsg = document.getElementById('status-msg');
            if (statusMsg) statusMsg.style.display = 'none'; 
            
            if (results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const index = results.multiHandLandmarks[0][8];
                targetX = (0.5 - index.x) * 120; 
                targetY = (0.5 - index.y) * 80;
            } else {
                isHandDetected = false;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        
        cameraUtils.start()
            .then(() => { console.log("Camera started"); })
            .catch(e => {
                console.log(e);
            });
    }

    window.addEventListener('resize', () => {
        // SAFETY CHECK: Prevent crash if camera not ready
        if (camera && renderer) {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });

    // Run when DOM is fully loaded
    window.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>
