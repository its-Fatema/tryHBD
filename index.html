<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Birthday Wish</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI OVERLAYS */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; justify-content: center; align-items: center;
        }

        /* CARD CREATOR BOX */
        #creator-box, #expired-msg {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #333;
            box-shadow: 0 0 20px cyan;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            color: white;
            pointer-events: auto;
            max-width: 400px;
            display: none; /* Hidden by default */
        }

        h1 { margin-top: 0; color: cyan; text-transform: uppercase; letter-spacing: 2px; }
        p { color: #ccc; }

        input {
            width: 80%; padding: 10px; margin: 15px 0;
            background: #111; border: 1px solid #555; color: white;
            border-radius: 5px; text-align: center; font-size: 1.2rem;
        }
        input:focus { outline: none; border-color: cyan; }

        button {
            background: linear-gradient(45deg, #ff0055, #ff00ff);
            border: none; padding: 12px 30px; color: white;
            font-size: 1rem; border-radius: 25px; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }
        button:hover { transform: scale(1.05); box-shadow: 0 0 15px #ff00ff; }

        .link-display {
            margin-top: 15px; word-break: break-all;
            font-size: 0.9rem; color: #00ffaa;
            background: #000; padding: 10px; border-radius: 5px;
            display: none; user-select: text;
        }

        /* LOADING SPINNER */
        #loading {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            color: white; font-family: sans-serif; pointer-events: none;
            text-shadow: 0 0 10px cyan;
            display: none; z-index: 5;
        }

        .input_video { display: none; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="creator-box">
            <h1>Create A Wish</h1>
            <p>Enter the birthday person's name below.</p>
            <input type="text" id="nameInput" placeholder="Name (e.g. Sarah)" maxlength="15">
            <br>
            <button onclick="generateLink()">Generate Magic Link</button>
            <div id="resultLink" class="link-display"></div>
            <p style="font-size: 0.8rem; margin-top:10px; opacity: 0.7;">Link expires in 5 minutes after creation.</p>
        </div>

        <div id="expired-msg">
            <h1 style="color: #555;">Wish Faded</h1>
            <p>This magical moment has expired in the winds of time.</p>
            <button onclick="window.location.href = window.location.pathname">Create New Wish</button>
        </div>
    </div>

    <div id="loading">Igniting Fireworks Engine...<br>Please Allow Camera Access</div>
    <video class="input_video"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    // --- CONFIG ---
    const urlParams = new URLSearchParams(window.location.search);
    const wishName = urlParams.get('n'); 
    const wishTime = urlParams.get('t');
    const EXPIRATION_MINUTES = 10; 

    let finalName = ""; 
    let isReceiverMode = false;

    // --- INITIALIZATION ---
    function init() {
        if (wishName && wishTime) {
            // --- RECEIVER VIEW ---
            const now = Date.now();
            const createdTime = parseInt(wishTime);
            const diffMinutes = (now - createdTime) / 1000 / 60;

            if (diffMinutes > EXPIRATION_MINUTES) {
                document.getElementById('status-msg').style.display = 'block';
                document.getElementById('status-msg').innerText = "✨ The magic has faded... (Link Expired)";
                document.getElementById('creator-controls').style.display = 'flex'; 
            } else {
                // VALID LINK
                finalName = atob(wishName); 
                isReceiverMode = true;
                
                document.getElementById('creator-controls').style.display = 'none';
                
                const status = document.getElementById('status-msg');
                status.style.display = 'block';
                status.innerText = "Igniting Magic Engine...";
                
                document.getElementById('hand-instruction').style.display = 'block';

                // CHECK FOR CAMERA SUPPORT BEFORE STARTING
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert("⚠️ CAMERA BLOCKED: Browsers do not allow camera access on 'file://' URLs. Please use 'Live Server' in VS Code or host this on Netlify/GitHub Pages.");
                    status.innerText = "Error: Camera requires HTTPS or Localhost.";
                    status.style.color = "red";
                } else {
                    startCamera();
                }
            }
        } 
        
        initThreeJS();
    }

    function generateLink() {
        const input = document.getElementById('nameInput').value.trim();
        if(!input) return alert("Enter a name first!");
        
        const encodedName = btoa(input); 
        const now = Date.now();
        const link = `${window.location.origin}${window.location.pathname}?n=${encodedName}&t=${now}`;
        
        navigator.clipboard.writeText(link).then(() => {
            alert("Link copied! \n\nIMPORTANT: If you send this link to yourself to test, make sure you are not opening it as a file://. Use a local server.");
        });
    }

    // --- THREE.JS VISUALS ---
    let scene, camera, renderer, particles, textMesh;
    let isHandDetected = false;
    let targetX = 0, targetY = 0;

    function initThreeJS() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.003);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        createText();
        createParticles();
        animate();
    }

    function createText() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024; 
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = 'rgba(0,0,0,0)'; 
        ctx.fillRect(0, 0, 1024, 1024);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.shadowColor = "#FF00FF";
        ctx.shadowBlur = 30;
        ctx.fillStyle = "white";
        ctx.font = "bold 90px Arial";
        ctx.fillText("HAPPY", 512, 350);

        ctx.shadowColor = "#00FFFF";
        ctx.fillText("BIRTHDAY", 512, 480);

        if(finalName) {
            ctx.shadowColor = "#FFD700"; 
            ctx.fillStyle = "#FFFACD"; 
            ctx.font = "bold 140px sans-serif"; 
            ctx.fillText(finalName.toUpperCase(), 512, 650);
        }

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ 
            map: texture, transparent: true, opacity: 0.95, 
            side: THREE.DoubleSide, blending: THREE.AdditiveBlending 
        });
        textMesh = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), material);
        textMesh.position.z = -10;
        scene.add(textMesh);
    }

    function createParticles() {
        const count = 12000;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const velocities = []; // Custom velocity storage
        const colors = [];
        const palette = [0xFF0055, 0xFFD700, 0x00FFFF, 0xFFFFFF]; 

        for (let i = 0; i < count; i++) {
            positions.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*100);
            velocities.push(0,0,0);
            const color = new THREE.Color(palette[Math.floor(Math.random()*palette.length)]);
            colors.push(color.r, color.g, color.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        // Custom attribute for velocity to persist it
        geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

        particles = new THREE.Points(geometry, new THREE.PointsMaterial({
            size: 0.8, vertexColors: true, blending: THREE.AdditiveBlending, 
            transparent: true, opacity: 0.8, depthWrite: false
        }));
        scene.add(particles);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        const posAttr = particles.geometry.attributes.position;
        const velAttr = particles.geometry.attributes.velocity;
        
        const pos = posAttr.array;
        const vel = velAttr.array; // Use the attribute array for storage
        
        const speed = isReceiverMode ? 0.1 : 0.05; 
        const returnStrength = 0.008;

        for (let i = 0; i < 12000; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            let px = pos[ix];
            let py = pos[iy];
            let pz = pos[iz];

            let vx = vel[ix]; // Retrieve previous velocity
            let vy = vel[iy];
            let vz = vel[iz];

            if (isHandDetected && isReceiverMode) {
                const dx = targetX - px;
                const dy = targetY - py;
                const dz = 20 - pz;
                const distSq = dx*dx + dy*dy + dz*dz;
                const force = Math.min(200/(distSq+1), 2) * speed;
                
                vx += dx * force * 0.1; // Accumulate force
                vy += dy * force * 0.1;
                vz += dz * force * 0.1;
            } else {
                const angle = Date.now() * 0.0001 + (i * 0.0005);
                const radius = 35 + Math.sin(Date.now()*0.0005 + i)*10;
                
                const tx = Math.cos(angle) * radius;
                const ty = Math.sin(angle) * (radius * 0.6);
                
                vx += (tx - px) * returnStrength;
                vy += (ty - py) * returnStrength;
                vz += (-10 - pz) * returnStrength;
            }

            // Friction
            vx *= 0.9; 
            vy *= 0.9;
            vz *= 0.9;

            pos[ix] += vx;
            pos[iy] += vy;
            pos[iz] += vz;
            
            // Store velocity back
            vel[ix] = vx;
            vel[iy] = vy;
            vel[iz] = vz;
        }
        
        posAttr.needsUpdate = true;
        velAttr.needsUpdate = true; // Important to save velocity
        
        if(textMesh) {
            textMesh.position.y = Math.sin(Date.now()*0.001)*2;
            textMesh.rotation.z = Math.sin(Date.now()*0.0005)*0.05;
        }

        renderer.render(scene, camera);
    }

    // --- HAND TRACKING (Only runs for Receiver) ---
    function startCamera() {
        const videoElement = document.getElementsByClassName('input_video')[0];
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults((results) => {
            document.getElementById('status-msg').style.display = 'none'; 
            if (results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const index = results.multiHandLandmarks[0][8];
                targetX = (0.5 - index.x) * 120; 
                targetY = (0.5 - index.y) * 80;
            } else {
                isHandDetected = false;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        
        cameraUtils.start()
            .then(() => { console.log("Camera started"); })
            .catch(e => {
                alert("Camera failed to start. Ensure you are on HTTPS or Localhost.");
            });
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init(); 

</script>

</body>
</html>
